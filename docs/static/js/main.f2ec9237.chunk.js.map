{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","useState","currentAccount","setCurrentAccount","waveCount","setWaveCount","allWaves","setAllWaves","message","setMessage","loading","setLoading","getAllWaves","a","window","ethereum","provider","ethers","providers","Web3Provider","signer","getSigner","waveportalContract","Contract","waveportal","abi","waves","wavesCleaned","map","wave","address","waver","timestamp","Date","sort","b","getTotalWaves","countBigNum","count","toNumber","check","on","from","console","log","newWave","prevState","checkIfWalletIsConnected","request","method","accounts","length","account","connectWallet","alert","e","preventDefault","gasLimit","waveTxn","wait","useEffect","className","onClick","onSubmit","style","width","type","placeholder","onChange","target","value","disabled","cursor","index","key","toString","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f2ec9237.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { ethers } from \"ethers\";\nimport \"./App.css\";\nimport waveportal from \"./utils/WavePortal.json\";\n\nconst App = () => {\n  const [currentAccount, setCurrentAccount] = useState(\"\");\n  const [waveCount, setWaveCount] = useState(-1);\n  const [allWaves, setAllWaves] = useState([]);\n  const [message, setMessage] = useState(\"\");\n  const [loading, setLoading] = useState(false);\n  const contractAddress = \"0x441a46f993FD3629f08Ec6d092D85F456DCDFAB6\";\n\n  const getAllWaves = async () => {\n    try {\n      const { ethereum } = window;\n\n      if (window.ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const waveportalContract = new ethers.Contract(\n          contractAddress,\n          waveportal.abi,\n          signer\n        );\n\n        const waves = await waveportalContract.getAllWaves();\n        let wavesCleaned = waves\n          .map((wave) => {\n            return {\n              address: wave.waver,\n              timestamp: new Date(wave.timestamp * 1000),\n              message: wave.message,\n            };\n          })\n          .sort((a, b) => b.timestamp - a.timestamp);\n        setAllWaves(wavesCleaned);\n        const countBigNum = await waveportalContract.getTotalWaves();\n        const count = countBigNum.toNumber();\n        setWaveCount(count);\n\n        let check = false;\n        waveportalContract.on(\"NewWave\", (from, timestamp, message) => {\n          console.log(\"NewWave\", from, timestamp, message);\n          let newWave = {\n            address: from,\n            timestamp: new Date(timestamp * 1000),\n            message: message,\n          };\n          if (check) {\n            setAllWaves((prevState) => [newWave, ...prevState]);\n            setWaveCount((prevState) => prevState + 1);\n          }\n          check = true;\n        });\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  const checkIfWalletIsConnected = async () => {\n    try {\n      const { ethereum } = window;\n\n      if (!ethereum) {\n        console.log(\"Make sure you have MetaMask!\");\n        return;\n      } else {\n        console.log(\"We have the ethereum object\", ethereum);\n      }\n\n      const accounts = await ethereum.request({ method: \"eth_accounts\" });\n\n      if (accounts.length !== 0) {\n        const account = accounts[0];\n        console.log(\"Found an authorized account:\", account);\n      } else {\n        console.log(\"No authorized account found\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  const connectWallet = async () => {\n    try {\n      const { ethereum } = window;\n\n      if (!ethereum) {\n        alert(\"Get MetaMask!\");\n        return;\n      }\n\n      const accounts = await ethereum.request({\n        method: \"eth_requestAccounts\",\n      });\n      console.log(\"Connected\", accounts[0]);\n      setCurrentAccount(accounts[0]);\n      getAllWaves();\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  const wave = async (e) => {\n    try {\n      e.preventDefault();\n      if (message === \"\") {\n        alert(\"Please add a message\");\n        return;\n      }\n      const { ethereum } = window;\n\n      if (ethereum) {\n        const provider = new ethers.providers.Web3Provider(ethereum);\n        const signer = provider.getSigner();\n        const waveportalContract = new ethers.Contract(\n          contractAddress,\n          waveportal.abi,\n          signer\n        );\n\n        const waveTxn = await waveportalContract.wave(message, {\n          gasLimit: 300000,\n        });\n        setLoading(true);\n\n        await waveTxn.wait();\n        setLoading(false);\n        setMessage(\"\");\n      } else {\n        console.log(\"Ethereum object doesn't exist!\");\n      }\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  useEffect(() => {\n    checkIfWalletIsConnected();\n    getAllWaves();\n  }, []);\n\n  return (\n    <div className=\"mainContainer\">\n      <div className=\"dataContainer\">\n        <div className=\"header\">ðŸ‘‹ Hey there!</div>\n\n        <div className=\"bio\">\n          My name is Dave, I have been mainly working with C# and SQL but I am\n          enjoying learning Web3, blockchain, and Ethereum. Connect your\n          Ethereum wallet and drop me a wave!\n        </div>\n\n        <div className=\"bio\">Total waves: {waveCount}</div>\n\n        {!currentAccount && (\n          <button className=\"waveButton\" onClick={connectWallet}>\n            Connect Wallet\n          </button>\n        )}\n        {currentAccount && (\n          <form onSubmit={wave} style={{ width: \"580px\" }}>\n            <label>Message:</label>\n            <input\n              className=\"message messageInput\"\n              type=\"text\"\n              placeholder=\"your message\"\n              onChange={(e) => setMessage(e.target.value)}\n              value={message}\n              disabled={loading}\n              style={{ cursor: loading ? \"wait\" : \"pointer\" }}\n            />\n            <input\n              className=\"waveButton submitButton\"\n              type=\"submit\"\n              value={loading ? \"Mining...\" : \"Wave at Me\"}\n              disabled={loading}\n              style={{ cursor: loading ? \"wait\" : \"pointer\" }}\n            />\n          </form>\n        )}\n\n        {allWaves.map((wave, index) => {\n          return (\n            <div className=\"message\" key={index}>\n              <div>\n                Message: <strong>{wave.message}</strong>\n              </div>\n              <div>Time: {wave.timestamp.toString()}</div>\n              <div>Address: {wave.address}</div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}